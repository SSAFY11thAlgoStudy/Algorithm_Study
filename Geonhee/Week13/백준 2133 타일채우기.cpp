#include <iostream>
#include <algorithm>
using namespace std;

//3xN크기의 벽인데 N이 홀수 일때 2x1과 1x2로 채울 수 있는 경우는 없음
int n;
int d[32];

int main() {
    cin >> n;
    //존재하지 않는 타일을 채우는 경우의 수는 타일하나도 사용 하지 않는 경우 1개
    d[0] = 1;

    //직접 만들어보면 가장 흔하게 채워지는 경우가 3가지 있는데
    // ||  ㅡ  ㅡ
    // ||  ㅡ  ||
    // ㅡ  ㅡ  ||
    //이렇게 3가지
    // d[4] = 3*2 + 3*2 + 특이한 모양2
    // d[6] = (3*4 + 3*2) + (3*2 + 3*4)인데 두번째 꺼에서 중복방지를 하려면
    // 각 * ?에 특이한 모양으로 세주면 된다.
    // 3*2 + 3*4에서 3*2는 무조건 위에 3모양으로 채워야하므로 3*4에서 중복을
    // 방지해주면 되는데 특이한 모양 넣어서 조합을 한다면 중복이 방지된다.
    // 그래서 3*2 *2 이런식으로 해주면 중복 방지해서 조합해 넣어갈 수 있다.
    // 각 d[x]마다 특이한 모양은 2개씩 늘어간다.
    //d[2] = d[0]*3
    //d[4] = d[2]*3 + d[0]*2
    //d[6] = d[4]*3 + d[2]*2 + d[0]*2
    //d[8] = d[6]*3 + d[4]*2 + d[2]*2 + d[0]*2 이런식으로 가는 걸 볼 수 있다.
    for (int i = 2; i < n + 1; i += 2) {
        //*3인 이유는 항상 쪼갤때 3*(n-2) + 3*2로 크게 쪼개므로 
        //3*2가 항상 3이므로 *3
        d[i] = d[i - 2] * 3;
        for (int j = i - 4; j > -1; j -= 2) {
            d[i] += d[j] * 2;
        }
    }
    cout << d[n];
    return 0;
}